<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>ZMap · Documentation</title>
		<meta name="description" context="some description should go here"/>
		
		<link href="css/bootstrap.min.css" rel="stylesheet"/>
		<link href="css/bootstrap-responsive.min.css" rel="stylesheet"/>
		<link href="css/local.css" rel="stylesheet"/>
	</head>
<script type="text/javascript">
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '51f73359108d7b36f5000203');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
	<body>
		<script type="text/JavaScript" src="js/jquery.min.js"></script> 
		<script type="text/JavaScript" src="js/bootstrap.min.js"></script> 
		<div class="navbar navbar-static-top navbar-inverse">
		  <div class="navbar-inner">
		    <a class="brand" href="index.html">ZMap · The Internet Scanner</a>
		    <ul class="nav pull-right">
					<li><a href="paper.html">Research Paper</a></li>
		      <li class="active"><a href="documentation.html">Documentation</a></li>
		        <li><a href="projects.html">Projects</a></li>
					<li><a href="download.html">Download</a></li>
		    </ul>
		  </div>
		</div>
	<div class="content">
			<div class="container">
				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 title">
						<div class="content">
						  <h3>ZMap Documentation</h3>
						  <div class="container">
						    <div class="row-fluid"> 
						      <div class="span4 offset1">
						        <p class="front"><b>1. <a href="#gettingstarted">Getting Started with ZMap</a></b></p>
						        <p class="front"><b>2. <a href="#bestpractices">Scanning Best Practices</a></b></p>
                                <p class="front"><b>3. <a href="#args">Command Line Arguments</a></b></p>
      							<p class="section"><b>4. <a href="#applications">Extending ZMap</a></b></p>
      							<ol class="subsection">
      							  <li><a href="#applications">Sample Applications</a></li>
      							  <li><a href="#extending">Writing Probe and Output Modules</a></li>
      							  </ol>
						      </div>
						      <div class="span5">
                                <p class="section"><b>5. <a href="#additional">Additional Information</a></b></p>
                                <ol class="subsection">
                                  <li><a href="#tcp_synscan">TCP SYN Probe Module</a></li>
                                  <li><a href="#icmp_echoscan">ICMP Echo Probe Module</a></li>
                                  <li><a href="#config">Configuration Files</a></li>
                                  <li><a href="#verbosity">Verbosity</a></li>
                                  <li><a href="#output">Results Output</a></li>
                                  <li><a href="#blacklisting">Blacklisting</a></li>
                                  <li><a href="#ratelimiting">Rate Limiting and Sampling</a></li>
                                  <li><a href="#multiple">Sending Multiple Probes</a></li>
                                </ol>
			      </div>
			    </div>
			  </div>
			</div>
			</div>
			<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="content">
                         <a name="gettingstarted"></a>
						  <h3>Getting Started with ZMap</h3>

                          <p class="front">
ZMap is designed to perform comprehensive scans of the IPv4 address space or large portions of it. While ZMap is a powerful tool for researchers, please keep in mind that by running ZMap, you are potentially scanning the <b>ENTIRE</b> IPv4 address space at over 1.4 million packets per second. Before performing even small scans, we encourage users to contact their local network administrators and consult our list of <a href="#bestpractices">scanning best practices</a>.</p>

                <p class="front">By default, ZMap will perform a TCP SYN scan on the specified
port at the maximum rate possible. A more conservative configuration that will scan 10,000 random
addresses on port 80 at a maximum 10 Mbps can be run as follows:</p>

                <div class="indent"><pre><b>$ zmap --bandwidth=10M --target-port=80 --max-targets=10000 --output-file=results.txt </b></pre></div>
                <p class="front">Or more concisely specified as:</p>
                <div class="indent"><pre><b>$ zmap -B 10M -p 80 -n 10000 -o results.txt</b></pre></div>
                <p class="front">If the scan started successfully, ZMap will output status updates every one second similar to the following:</p>
<div class="indent"><pre>
0% (1h51m left); send: 28777 562 Kp/s (560 Kp/s avg); recv: 1192 248 p/s (231 p/s avg); hits: 0.04%
0% (1h51m left); send: 34320 554 Kp/s (559 Kp/s avg); recv: 1442 249 p/s (234 p/s avg); hits: 0.04%
0% (1h50m left); send: 39676 535 Kp/s (555 Kp/s avg); recv: 1663 220 p/s (232 p/s avg); hits: 0.04%
0% (1h50m left); send: 45372 570 Kp/s (557 Kp/s avg); recv: 1890 226 p/s (232 p/s avg); hits: 0.04%</pre></div>

<p class="front">These updates provide information about the current state of the scan and are of the following form: %-complete (est time remaining); packets-sent curr-send-rate (avg-send-rate); recv: packets-recv recv-rate (avg-recv-rate); hits: hit-rate </p>

                <p class="front">If you do not know the scan rate that your
network can support, you may want to experiment with different scan rates or
bandwidth limits to find the fastest rate that your network can support before
you see decreased results.</p>

<p class="front">By default, ZMap will output the list of distinct IP addresses
that responded with a SYN ACK as they are found, similar to the
following. There are several additional formats for <a href="#output">outputting
results</a> as well as options for producing <a href="#verbosity">programmatically
parsable scan statistics</a>.</p>

                <div class="indent"><pre>115.237.116.119
23.9.117.80
207.118.204.141
217.120.143.111
50.195.22.82
</pre></div>


<p class="front">We strongly encourage you to use a <a href="#blacklisting">blacklist file</a>, to exclude both reserved/unallocated IP space (e.g. multicast, RFC1918), as well as networks that request to be excluded from your scans. By default, ZMap will utilize a simple blacklist file containing reserved and unallocated addresses located at <code>/etc/zmap/blacklist.conf</code>. If you find yourself specifying certain settings, such as your maximum bandwidth or <a href="#blacklisting">blacklist file</a> every time you run ZMap, you can specify these in <code>/etc/zmap/zmap.conf</code> or use a custom <a href="#config">configuration file</a>.</p>

     <p class="front">If you are attempting to troubleshoot scan related issues, there are several options to help debug. First, it is possible can perform a <a href="#dryrun">dry run scan</a> in order to see the packets that would be sent over the network by adding the <code>--dryrun</code> flag. As well, it is possible to change the <a href="#verbosity">logging verbosity</a> by setting the <code>--verbosity=n</code> flag.
    </p>   

<p class="front">
</p>
       <p class="front">
     
	</div>
	</div>
	<div class="row-fluid"> 
	<div class="span10 white-panel offset1 nontitle">
	<div class="hometitle">
	  <a name="bestpractices"></a>
	  <h3>Scanning Best Practices</h3>
              <p class="front">
                We offer these suggestions for researchers conducting Internet-wide scans as guidelines for good Internet citizenship.</p>
                <ol class="recommendations">
                  <li class="">Coordinate closely with local network administrators to
                  reduce risks and handle inquiries</li>
                  <li class="">Verify that scans will not overwhelm the local network or upstream provider</li>
                  <li class="">Signal the benign nature of the scans in web pages
                  and DNS entries of the source addresses</li>
                  <li class="">Clearly explain the purpose and scope of the scans
                  in all communications</li>
                  <li class="">Provide a simple means of opting out and honor
                  requests promptly</li>
                  <li class="">Conduct scans no larger or more frequent than is
                  necessary for research objectives</li>
                  <li class="">Spread scan traffic over time or source addresses
                  when feasible</li>
                </ol>
                <p class="front">It should go without saying that scan
                researchers should refrain from exploiting vulnerabilities or accessing protected resources, and should comply
                with any special legal requirements in their jurisdictions.</p>
					</div>
				</div>


<!-- Command Line Arguments -->
<div class="row-fluid">
  <div class="span10 white-panel offset1 nontitle">
    <div class="content">
    <a name="args"></a>
    <h3>Command Line Arguments</h3>


        <h4>Common Options</h4>
	<p>These options are the most common options when performing a simple scan. We note that some options are dependent on the <a href="#probemodule">probe module</a> or <a href="#outputmodule">output module</a> used (e.g. target port is not used when performing an ICMP Echo Scan). </p>

        <dl class="dl-horizontal params">
          <dt>-p, --target-port=port</dt>       <dd>TCP port number to scan (e.g. <b>443</b>)</dd>
          <dt>-o, --output-file=name</dt>       <dd>Write results to this file. Use - for stdout</dd>
          <dt>-b, --blacklist-file=path</dt>    <dd>File of subnets to exclude, in CIDR notation (e.g. 192.168.0.0/16), 
                                                    one-per line. It is recommended you use this to exclude RFC 1918 addresses,
                                                    multicast, IANA reserved space, and other IANA special-purpose addresses. 
                                                    An example blacklist file is provided in <b>conf/blacklist.example</b>
                                                    for this purpose.</dd>
        </dl>
        <a name="scanoptions"></a>
        <h4>Scan Options</h4>

        <dl class="dl-horizontal params">
          <dt>-n, --max-targets=n</dt>          <dd>Cap the number of targets to probe. This can either be a number (e.g. <code>-n 1000</code>)
                                                or a percentage (e.g. <code>-n 0.1%</code>) of the scannable address space (after excluding blacklist)</dd>
          <dt>-N, --max-results=n</dt>          <dd>Exit after receiving this many results</dd>
          <dt>-t, --max-runtime=secs</dt>       <dd>Cap the length of time for sending packets</dd>
          <dt>-r, --rate=pps</dt>               <dd>Set the send rate in packets/sec</dd>
          <dt>-B, --bandwidth=bps</dt>          <dd>Set the send rate in bits/second (supports suffixes G, M, and K (e.g. <code>-B 10M</code> for 10 mbps).
                                                This overrides the <code>--rate</code> flag.</dd>

          <dt>-c, --cooldown-time=secs</dt>     <dd>How long to continue receiving after sending has completed (default=8)<dd>
          <dt>-e, --seed=n</dt>                 <dd>Seed used to select address permutation. Use this if you want to
                                                scan addresses in the same order for multiple ZMap runs.</dd>
          <dt>-T, --sender-threads=n</dt>       <dd>Threads used to send packets (default=1)</dd>
          <dt>-P, --probes=n</dt>               <dd>Number of probes to send to each IP (default=1)</dd>
          <dt>-d, --dryrun</dt>                 <dd>Print out each packet to stdout instead of sending it (useful for debugging)</dd>
        </dl> 

        <h4>Network Options</h4>

        <dl class="dl-horizontal params">
          <dt>-s, --source-port=port|range</dt> <dd>Source port(s) to send packets from</dd>
          <dt>-S, --source-ip=ip|range</dt>     <dd>Source address(es) to send packets from. Either single IP or range (e.g. 10.0.0.1-10.0.0.9)</dd>
          <dt>-G, --gateway-mac=addr</dt>       <dd>Gateway MAC address to send packets to (in case auto-detection does not work)</dd>
          <dt>-i, --interface=name</dt>         <dd>Network interface to use</dd>
        </dl>

        <h4>Module Options</h4>

        <p>ZMap allows users to specify and write their own modules for use with ZMap. ZMap supports two types of modules:
        <a href="#probemodule">Probe modules</a> and <a href="#outputmodule">output modules</a>. Probe modules are responsible for
        generating probe packets to send, and classifying responses from hosts. Output modules are responsible for displaying or storing
        results as they are produced during a scan.</p>

        <dl class="dl-horizontal params">
          <dt>-M, --probe-module=name</dt>      <dd>Select <a href="#probemodule">probe module</a> (default=tcp_synscan)</dd>
          <dt>-O, --output-module=name</dt>     <dd>Select <a href="#outputmodule">output module</a> (default=simple_file)</dd>
          <dt>--probe-args=args</dt>            <dd>Arguments to pass to probe module</dd>
          <dt>--output-args=args</dt>           <dd>Arguments to pass to output module</dd>
          <dt>--list-output-modules</dt>        <dd>List available output modules (e.g. tcp_synscan)</dd>
          <dt>--list-probe-modules</dt>		<dd>List available probe modules (e.g. extended_file)</dd>
        </dl>

        <h4>Additional Options</h4>
        <dl class="dl-horizontal params">
          <dt>-C, --config=filename</dt>        <dd>Read a <a href="#config">configuration file</a>, which can specify any other options.</dd>
          <dt>-q, --quiet</dt>                  <dd>Do not print status updates once per second</dd>
          <dt>-g, --summary</dt>                <dd>Print configuration and summary of results at the end of the scan</dt>
          <dt>-v, --verbosity=n</dt>            <dd>Level of log detail (0-5, default=3)</dd>
          <dt>-h, --help</dt>                   <dd>Print help and exit</dd>
          <dt>-V, --version</dt>                <dd>Print version and exit</dd>
        </dl>
    </div>
  </div>
</div>
			
	<div class="row-fluid"> 
      	  <div class="span10 white-panel offset1 nontitle">
           <div class="content">
             <a name="applications"></a>
	     <h3>Sample Applications</h3>
	  	<p>ZMap is designed for initiating contact with a large number of hosts and finding ones
                          that respond positively. However, we realize that many users will want to perform follow-up processing, such as performing an application level handshake. For example, users who perform a TCP SYN scan on port 80 might want to perform a simple GET request and users who scan port 443 may be interested in completing a TLS handshake.</p>

                         <a name="banner-grab"></a>
                         <h4>Banner Grab</h4>

                         <p>We have included a sample application, banner-grab, with ZMap that enables users
                         to receive messages from listening TCP servers. Banner-grab connects to the provided servers,
                         optionally sends a message, and prints out the first message received from the server. This tool
                         can be used to fetch banners such as HTTP server responses to specific commands, telnet login
                         prompts, or SSH server strings.</p>

                         <p>This example finds 1000 servers listening on port 80, and sends a simple GET request to each,
                         storing their base-64 encoded responses in http-banners.out</p>
                         <div class="indent"><pre><b>$ zmap -p 80 -N 1000 -B 10M -o - | ./banner-grab-tcp -p 80 -c 500 -d ./http-req &gt; out</b></pre></div>
                         <p>For more details on using <code>banner-grab</code>, see the README file in <code>examples/banner-grab</code>.</p>

                         <p><span class="label label-info">Heads Up!</span>
                         ZMap and banner-grab can have significant performance and accuracy impact on
                         one another if run simultaneously (as in the example). Make sure not to let
                         ZMap saturate banner-grab-tcp's concurrent connections, otherwise banner-grab
                         will fall behind reading stdin, causing ZMap to block on writing stdout. We 
                         recommend using a slower scanning rate with ZMap, and increasing the concurrency
                         of banner-grab-tcp to no more than 3000 (Note that &gt; 1000 concurrent connections
                         requires you to use <code>ulimit -SHn 100000</code> and <code>ulimit -HHn 100000</code>
                         to increase the maximum file descriptors per process). These parameters will of course
                         be dependent on your server performance, and hit-rate; we encourage developers to experiment
                         with small samples before running a large scan.</p>

                         <a name="forge-socket"></a>
                         <h4>Forge Socket</h4>

						<p>We have also included a form of banner-grab, called forge-socket, that reuses the SYN-ACK
						sent from the server for the connection that ultimately fetches the banner. In <code>banner-grab-tcp</code>,
						ZMap sends a SYN to each server, and listening servers respond with a SYN+ACK. The ZMap host's kernel receives
						this, and sends a RST, as no active connection is associated with that packet. The banner-grab program must
						then create a new TCP connection to the same server to fetch data from it.</p>

						<p>In forge-socket, we utilize a kernel module by the same name, that allows us to create a connection
						with arbitrary TCP parameters. This enables us to suppress the kernel's RST packet, and instead
						create a socket that will reuse the SYN+ACK's parameters, and send and receive data through this socket
						as we would any normally connected socket.</p>

						<p>To use forge-socket, you will need the forge-socket kernel module, available from
						<a href="https://github.com/ewust/forge_socket/">github</a>. You should <code>git clone git@github.com:ewust/forge_socket.git</code>
						in the ZMap root source directory, and then <code>cd</code> into the forge_socket directory, and run <code>make</code>.
						Install the kernel module with <code>insmod forge_socket.ko</code> as root.</p>

						<p>You must also tell the kernel not to send RST packets. An easy way to disable RST packets system wide is
						to use <b>iptables</b>. <code>iptables -A OUTPUT -p tcp -m tcp --tcp-flgas RST,RST RST,RST -j DROP</code> as root will
						do this, though you may also add an optional <code>--dport X</code> to limit this to the port (X) you are scanning.
						To remove this after your scan completes, you can run <code>iptables -D OUTPUT -p tcp -m tcp --tcp-flags RST,RST RST,RST -j DROP</code> 
						as root. </p>
		
						<p>Now you should be able to build the forge-socket ZMap example program. To run it, you must use the <b>extended_file</b>
						ZMap <a href="#outputmodule">output module</a>:</p>
	
                         <div class="indent"><pre>
<b>$ zmap -p 80 -N 1000 -B 10M -O extended_file -o - | \
    ./forge-socket -c 500 -d ./http-req &gt; ./http-banners.out</b></pre></div>

						<p>See the README in <code>examples/forge-socket</code> for more details.</p>
             
					</div>
				</div>
				
								<div class="row-fluid"> 
        					<div class="span10 white-panel offset1 nontitle">
        						<div class="content">
                                 <a name="extending"></a>
        						  <h3>Writing Probe and Output Modules</h3>
        		<p>ZMap can be extended to support different types of scanning through <strong>probe modules</strong> and additional types of results output through <strong>output modules</strong>. Registered probe and output modules can be listed through the command-line interface:</p>
        							<dl class="dl-horizontal params">
        								<dt>--list-probe-modules</dt><dd>Lists installed probe modules</dd>
        								<dt>--list-output-modules</dt><dd>Lists installed output modules</dd>
        							</dl><br/>

                     <a name="outputmodule"></a>
                      <h4>Output Modules</h4>
        							<p>ZMap output and post-processing can be extended by implementing and registering <strong>output modules</strong> with the scanner. Output modules receive a callback for every received response packet. While the default provided modules provide simple output, these modules are also capable of performing additional post-processing (e.g. tracking duplicates or outputting numbers in terms of AS instead of IP address)</p><br/>

        <p>Output modules are created by defining a new output_module struct and registering it in <a href="https://github.com/zmap/zmap/blob/v1.0.0/src/output_modules/output_modules.c">output_modules.c</a>:</p>

        <div class="indent"><pre>
struct output_module {
	const char          *name;           <em>// how is output module referenced in the CLI</em>
	unsigned            update_interval; <em>// how often is update called in seconds</em>
	
	output_init_cb      init;            <em>// called at scanner initialization</em>
	output_update_cb    start;           <em>// called at the beginning of scanner</em>
	output_update_cb    update;          <em>// called every update_interval seconds</em>
	output_update_cb    close;           <em>// called at scanner termination</em>
	
	output_packet_cb    success_ip;      <em>// called when a successful response is received</em>
	output_packet_cb    other_ip;        <em>// called when any other responses are received</em>

} output_module_t;</pre></div>

        <p>Output modules must have a name, which is how they are referenced on the command-line and generally implement <code>success_ip</code> and oftentimes <code>other_ip</code> callback. The success_ip callback is called for every response packet that is received and is classified as a success (e.g. TCP SYN/ACK or ICMP echo response) by the current <strong>probe module</strong>. The <code>other_ip</code> callback is called whenever a non-successful, but valid response (e.g. TCP RST or ICMP route unreachable) is received. These callbacks must define functions that match the <code>output_packet_cb</code> definition:</p>

        <div class="indent"><pre>
int (*output_packet_cb) (

    ipaddr_n_t    saddr,         <em>// IP address of scanned host in network-order</em>
    ipaddr_n_t    daddr,         <em>// destination IP address in network-order </em>
    
    const char*   response_type, <em>// send-module classification of packet</em>
    
    int           is_repeat,     <em>// {0: first response from host, 1: subsequent responses}</em>
    int           in_cooldown,   <em>// {0: not in cooldown state, 1: scanner in cooldown state}</em>
    
    const u_char* packet,        <em>// pointer to <code>struct iphdr</code> of IP packet</em>
    size_t        packet_len     <em>// length of packet in bytes</em> 
);
        </pre></div>

        <p>An output module can also register callbacks to be executed at scanner initialization (tasks such as opening an output file), start of the scan (tasks such as documenting blacklisted addresses), during regular intervals during the scan (tasks such as progress updates), and close (tasks such as closing any open file descriptors). These callbacks are provided with complete access to the scan configuration and current state:</p>
        <div class="indent"><pre>int (*output_update_cb)(struct state_conf*, struct state_send*, struct state_recv*);</pre></div>
        <p>which are defined in <a href="https://github.com/zmap/zmap/blob/v1.0.0/src/output_modules/output_modules.h">output_modules.h</a>. An example is available at <a href="https://github.com/zmap/zmap/blob/v1.0.0/src/output_modules/module_extended_file.c">src/output_modules/module_extended_file.c</a>.</p>
        <br/>

	<a name="probemodule"></a>
        <h4>Probe Modules</h4>

        <p>Packets are constructed using <strong>probe modules</strong> which
        allow abstracted packet creation and response classification. ZMap comes with
        two scan modules by default: <code>tcp_synscan</code> and
        <code>icmp_echoscan</code>. By default, ZMap uses <code>tcp_synscan</code>,
        which sends TCP SYN packets, and classifies responses from each host
        as open (received SYN+ACK) or closed (received RST). ZMap also allows developers
        to write their own probe modules for use with ZMap, using the following API.</p>

        <p>Each type of scan is implemented by developing and registering the necessary callbacks in a <code>send_module_t</code> struct:</p>

        <div class="indent"><pre>
typedef struct probe_module {
    const char               *name;             <em>// how scan is invoked on command-line</em>
    size_t                   packet_length;     <em>// how long is probe packet (must be static size)</em>
    
    const char               *pcap_filter;      <em>// PCAP filter for collecting responses</em>
    size_t                   pcap_snaplen;      <em>// maximum number of bytes for libpcap to capture</em>
    
    uint8_t                  port_args;         <em>// set to 1 if ZMap requires a <code>--target-port</code> be
                                                // specified by the user</em>
    
    probe_global_init_cb     global_initialize; <em>// called once at scanner initialization</em>
    probe_thread_init_cb     thread_initialize; <em>// called once for each thread packet buffer</em>
    probe_make_packet_cb     make_packet;       <em>// called once per host to update packet</em>
    probe_validate_packet_cb validate_packet;   <em>// called once per received packet, 
                                                // return 0 if packet is invalid,
                                                // non-zero otherwise.</em>
    
    probe_print_packet_cb    print_packet;      <em>// called per packet if in dry-run mode</em>
    probe_classify_packet_cb classify_packet;   <em>// called by receiver to classify response</em>
    probe_close_cb           close;             <em>// called at scanner termination</em>
    
    response_type_t          *responses;        <em>// possible response classifications</em>
    
} probe_module_t;
        </pre>

        <br/><p>At scanner initialization, <code>global_initialize</code> is
        called once and can be utilized to perform any necessary global configuration
        or initialization. However, <code>global_initialize</code> does not have access
        to the packet buffer which is thread-specific. Instead,
        <code>thread_initialize</code> is called at the initialization of each sender
        thread and is provided with access to the buffer that will be used for
        constructing probe packets along with global source and destination values.
        This callback should be used to construct the host agnostic packet structure
        such that only specific values (e.g. destination host and checksum) need to be
        be updated for each host. For example, the Ethernet header will not change
        between headers (minus checksum which is calculated in hardware by the NIC) and
        therefore can be defined ahead of time in order to reduce overhead at scan
        time.</p>

        <p>The <code>make_packet</code> callback is called for each host that
        is scanned to allow the <strong>probe module</strong> to update host specific
        values and is provided with IP address values, an opaque validation string,
		and probe number (shown below). The probe module is responsible for placing
		as much of the verification string into the probe, in such a way that when
		a valid response is returned by a server, the probe module can verify that
		it is present. For example, for a TCP SYN scan, the tcp_synscan probe module
		can use the TCP source port and sequence number to store the validation string.
		Response packets (SYN+ACKs) will contain the expected values in the destination
		port and acknowledgement number.</p>


        <div class="indent"><pre>
int make_packet(
    void        *packetbuf,  <em>// packet buffer</em>
    ipaddr_n_t  src_ip,      <em>// source IP in network-order</em>
    ipaddr_n_t	dst_ip,      <em>// destination IP in network-order</em>
    uint32_t    *validation, </em>// validation string to place in probe</em>
    int         probe_num    </em>// if sending multiple probes per host,
                             // this will be which probe number for this
                             // host we are currently sending</em>
);</pre></div><br/>

        <p>Scan modules must also define <code>pcap_filter</code>, <code>validate_packet</code>, and <code>classify_packet</code>. Only packets that match the PCAP filter will be considered by the scanner. For example, in the case of a TCP SYN scan, we only want to investigate TCP SYN/ACK or TCP RST packets and would utilize a filter similar to <code>tcp && tcp[13] & 4 != 0 || tcp[13] == 18</code>. The <code>validate_packet</code> function will be called for every packet that fulfills this PCAP filter. If the validation returns non-zero, the <code>classify_packet</code> function will be called, and return one of several responses pre-defined by the probe module. You will need to register possible responses, similar to the following:</p>

        <div class="indent"><pre>
static response_type_t responses[] = {
    {
        .is_success = 1,	
        .name = "synack"
    },
    {
        .is_success = 0,
        .name = "rst"
    }
};
</pre></div><br/>

<p>The classify function should accept a packet buffer and return a const response_type_t pointer to one of these responses upon receiving the packet. This classification will later be used as part of determining the scan output.</p>
        					</div>
        				</div>

				</div>  

				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="content">
                        <a name="additional"></a>
						  <h3>Additional Information</h3>

						

<!--
						<p>ZMap uses different arguments depending on the <a href="#probemodule">probe module</a> used.
						The default probe module is the TCP SYN scan (<code>-M tcp_synscan</code>).

	      <p> ZMap supports sending packets from multiple source IP
addresses and in the case of TCP SYN scans, from multiple ports.  Because ZMap
utilizes a raw socket to send network packets and <b>libpcap</b> to collect
responses, ZMap must be run as root or with <b>cap_net_raw</b> (recommended).
In the case that you want packets sent through a non-default interface, this
can be be set by providing the <strong>interface</strong> argument.</p> <p>
Basic arguments:</p>
							
							<dl class="dl-horizontal params">
								<dt>-S, - -source-ip=ip|range</dt><dd>Source address(es) for scan packets (e.g. <b>1.1.1.3-1.1.1.8</b>)</dd>
							  	<dt>-G, - -gateway-mac=addr</dt><dd>Specify gateway MAC address (e.g. <b>b4:23:f9:28:fa:2d</b>)</dd>
								<dt>-I, - -interface=name</dt><dd>Specify network interface to use (e.g. <b>eth1</b>)</dd>
							</dl>
							
<p><span class="label label-info">Heads Up!</span> One of the reasons that ZMap supports sending
packets from multiple addresses and source ports is because this allows the
scanner to embed small amounts of packet checksum data in these fields. This
functionality helps the scanner separate legitimate responses from extraneous
responses that may be received during scan runtime.</p>	
-->
							<a name="tcp_synscan"></a>									
							<h4>TCP SYN Scans</h4>
							<p>When performing a TCP SYN scan, ZMap requires a single target port and supports specifying a range of source ports from which the scan will originate.</p>
							<dl class="dl-horizontal params">
								<dt>-p, --target-port=port</dt><dd>TCP port number to scan (e.g. <b>443</b>)</dd>
								<dt>-s, --source-port=port|range</dt><dd>Source port(s) for scan packets (e.g. <strong>40000-50000</strong>)</dd>
							</dl>

                            <p><span class="label
label-warning">Warning!</span> ZMap relies on the Linux kernel to respond to
SYN/ACK packets with RST packets in order to close connections opened by the
scanner. This occurs because ZMap sends packets at the Ethernet layer in order
to reduce overhead otherwise incurred in the kernel from tracking open TCP
connections and performing route lookups. As such, if you have a firewall rule
that tracks established connections such as a netfilter rule similar to
<code>-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>, this will
block SYN/ACK packets from reaching the kernel. This will not prevent ZMap from
recording responses, but it will prevent RST packets from being sent back,
ultimately using up a connection on the scanned host until your connection
times out. We strongly recommend that you select a set of unused ports on your
scanning host which can be allowed access in your firewall and specifying this
port range when executing ZMap, with the <code>-s</code> flag (e.g. <code>-s '50000-60000'</code>).

<a name="icmp_echoscan"></a>		
<h4>ICMP Echo Request Scans</h4>
	<p>While ZMap performs TCP SYN scans by default, it also supports ICMP echo request scans in which an ICMP echo request packet is sent to each host and the type of ICMP response received in reply is denoted. An ICMP scan can be performed by selecting the <strong>icmp_echoscan</strong> scan module similar to the following:</p>
							<div class="indent"><pre><b> $ zmap --probe-module=icmp_echoscan</b></pre></div>
							<br/>

<a name="udp"></a>
<h4>UDP Datagram Scans</h4>
	<p>ZMap additionally supports UDP probes, where it will send out an arbitrary UDP datagram to each host, and receive either UDP or ICMP Unreachable responses. Currently, the datagram payload is set in <a href="https://github.com/zmap/zmap/blob/v1.0.0/src/probe_modules/module_udp.c#L29">probe_modules/module_udp.c</a>, and must be NULL-terminated. In the futurue, we will support arbitrary, command-line provided data payloads for UDP.</p>

		<div class="indent"><pre><b> $ zmap --probe-module=udp -p 53 -N 100 -o -</b></pre></div>



                            <a name="config"></a>
							<h3>Configuration Files</h3>

                            <p>ZMap supports configuration files instead of
requiring all options to be specified on the command-line. A configuration can
be created by specifying one long-name option and the value per line such
as:</p>

							<div class="indent"><pre>
interface "eth1"
source-ip 1.1.1.4-1.1.1.8
gateway-mac b4:23:f9:28:fa:2d # upstream gateway
cooldown-time 300 # seconds
blacklist-file /etc/zmap/blacklist.conf
output-file ~/zmap-output
quiet
summary
</pre></div>

<p>ZMap can then be run with a configuration file and specifying any additional necessary parameters:</p>
<div class="indent"><pre><b> $ zmap --config=~/.zmap.conf --target-port=443</b></pre></div>

							<br/>

							<a name="verbosity"></a>
							<h3>Verbosity</h3>
							<p>There are several types of on-screen output that ZMap produces. By default, ZMap will print out basic progress information similar to the following every 1 second. This can be disabled by setting the <code>--quiet</code> flag.</p>
							<div class="indent"><pre>0:01 12%; send: 10000 done (15.1 Kp/s avg); recv: 144 143 p/s (141 p/s avg); hits: 1.44%</pre></div>

<br/>
<p>ZMap also prints out informational messages during scanner configuration such as the following, which can be controlled with the <code>--verbosity</code> argument.</p>
<div class="indent"><pre>
Aug 11 16:16:12.813 [INFO] zmap: started
Aug 11 16:16:12.817 [DEBUG] zmap: no interface provided. will use eth0
Aug 11 16:17:03.971 [DEBUG] cyclic: primitive root: 3489180582
Aug 11 16:17:03.971 [DEBUG] cyclic: starting point: 46588
Aug 11 16:17:03.975 [DEBUG] blacklist: 3717595507 addresses allowed to be scanned
Aug 11 16:17:03.975 [DEBUG] send: will send from 1 address on 28233 source ports
Aug 11 16:17:03.975 [DEBUG] send: using bandwidth 10000000 bits/s, rate set to 14880 pkt/s
Aug 11 16:17:03.985 [DEBUG] recv: thread started
</pre></div>
<br/>
<p>ZMap also supports printing out a grep-able summary at the end of the scan, similar to below, which can be invoked with the <code>--summary</code> flag.</p>
<div class="indent"><pre>
cnf	target-port				443
cnf	source-port-range-begin			32768
cnf	source-port-range-end			61000
cnf	source-addr-range-begin			1.1.1.4
cnf	source-addr-range-end			1.1.1.8
cnf	maximum-packets				4294967295
cnf	maximum-runtime				0
cnf	permutation-seed			0
cnf	cooldown-period				300
cnf	send-interface				eth1
cnf	rate					45000
env	nprocessors				16
exc	send-start-time				Fri Jan 18 01:47:35 2013
exc	send-end-time				Sat Jan 19 00:47:07 2013
exc	recv-start-time				Fri Jan 18 01:47:35 2013
exc	recv-end-time				Sat Jan 19 00:52:07 2013
exc	sent					3722335150
exc	blacklisted				572632145
exc	first-scanned				1318129262
exc	hit-rate				0.874102
exc	synack-received-unique			32537000
exc	synack-received-total			36689941
exc	synack-cooldown-received-unique		193
exc	synack-cooldown-received-total		1543
exc	rst-received-unique			141901021
exc	rst-received-total			166779002
adv	source-port-secret			37952
adv	permutation-gen				4215763218
</pre></div>
<br/>
<!--
<p>Verbosity Arguments:</p>
<dl class="dl-horizontal params">
	<dt>-q, --quiet</dt><dd>Do not print update regular status updates</dd>
	<dt>-g, --summary</dt><dd>Provide a greppable summary at the end of the scan</dd>
	<dt>-v, --verbosity=n</dt><dd>Level of output detail (n=0-5; 5 is most verbose)</dd>
	<dt>-h, --help</dt><dd>Print help and exit</dd>
	<dt>-V, --version</dt><dd>Print version and exit</dd>
</dl>
<br/>
-->

<!--
							<a name="dryrun"></a>
							<h4>Dry-Run Mode</h4>
							<p>Dry-run mode allows you test your configuration and find what packets will be sent without creating any traffic.</p> <dl class="dl-horizontal params">
								<dt>-d, --dryrun</dt><dd>Don't send actual packets</dd>
							</dl>
							
							<p>Instead of sending any traffic, ZMap will produce an output similar to the following:</p>
											
<pre>tcp { source: 46870 | dest: 443 | seq: 15587922 | checksum: 2520973312 }
ip { saddr: 1.1.1.4 | daddr: 98.28.28.36 | checksum: 910295040 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }
---------------------------------------------------------------------------------
tcp { source: 52413 | dest: 443 | seq: 15587922 | checksum: 1787953152 }
ip { saddr: 1.1.1.4 | daddr: 114.144.33.186 | checksum: 540540928 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }
---------------------------------------------------------------------------------
tcp { source: 38524 | dest: 443 | seq: 15587922 | checksum: 3076063232 }
ip { saddr: 1.1.1.4 | daddr: 177.175.204.20 | checksum: 918421504 }
eth { shost: 00:8b:24:d4:5b:f3 | dhost: b4:23:f9:28:fa:2d }</pre><br/>
-->
							<a name="output"></a> 
							<h3>Results Output</h3>


                                <p>ZMap can produce results in several formats
through the use of output modules. ZMap currently supports three output
formats: <strong>simple-file</strong>, <strong>extended-file</strong>, and
<strong>redis</strong> (if built with redis support). By default, ZMap will
return results in the simple-file format and if no output file is specified,
ZMap will not produce specific results. It is also possible to write your own
output module; see <a href="#extending">Writing Output Modules</a> for information.</p>
								
								<dl class="dl-horizontal params">
									<dt>-o, --output-file=p</dt><dd>File to write list of live IPs to</dd>
								  <dt>-O, --output-module=p</dt><dd>Invoke a custom output module</dd>
									<dt>--list-output-modules</dt><dd>Lists available output modules</dd>
								</dl><br/>
								
								<h4>Simple File</h4>
								<p>The simple file module will produce an output file containing only the unique IP addresses that responded successfully (e.g. SYNACK packet for TCP SYN scan). Example:
<div class="indent"><pre>115.237.116.119
23.9.117.80
207.118.204.141
217.120.143.111
50.195.22.82
31.6.64.244
145.216.89.22
68.171.59.173</pre></div><br/>


								<h4>Extended File</h4>
								<p>The extended file module will produce a detailed record of all responses received from the scan:</p>
<div class="indent"><pre>
response, saddr, daddr, sport, dport, seq, ack, in_cooldown, is_repeat, timestamp
synack, 159.174.153.144, 10.0.0.9, 80, 40555, 3050964427, 3515084203, 0, 0,2013-08-15 18:55:47.681
rst, 141.209.175.1, 10.0.0.9, 80, 40136, 0, 3272553764, 0, 0,2013-08-15 18:55:47.683
rst, 72.36.213.231, 10.0.0.9, 80, 56642, 0, 2037447916, 0, 0,2013-08-15 18:55:47.691
rst, 148.8.49.150, 10.0.0.9, 80, 41672, 0, 1135824975, 0, 0,2013-08-15 18:55:47.692
rst, 50.165.166.206, 10.0.0.9, 80, 38858, 0, 535206863, 0, 0,2013-08-15 18:55:47.694
rst, 65.55.203.135, 10.0.0.9, 80, 50008, 0, 4071709905, 0, 0,2013-08-15 18:55:47.700
synack, 50.57.166.186, 10.0.0.9, 80, 60650, 2813653162, 993314545, 0, 0,2013-08-15 18:55:47.704
synack, 152.75.208.114, 10.0.0.9, 80, 52498, 460383682, 4040786862, 0, 0,2013-08-15 18:55:47.707
synack, 23.72.138.74, 10.0.0.9, 80, 33480, 810393698, 486476355, 0, 0,2013-08-15 18:55:47.710
</pre></div><br/>
								<h4>Redis</h4>
<p>The redis output module allows addresses to be added to a Redis queue instead of being saved to file which ultimately allows ZMap to be incorporated with post processing tools.</p
  
  <p> <span class="label label-info">Heads Up!</span> ZMap does not build with Redis support by default. If you are building ZMap from source, you can build with Redis support by running <code>make REDIS=true</code>.</p>
														<br/>


<!--
							<a name="address"></a> 
							<h3>Scan Order and Address Selection</h3>
							
							<p>IP addresses are scanned in a random permutation that is generated at the beginning of each scan. If you want to scan addresses in the same order over multiple scans or to scan the same subset of the IPv4 address space (see <a href="#sampling">sampling</a>), you can specify the permutation by specifying the seed option. It is not possible to specify the exact order in which addresses are scanned.</p>

							<dl class="dl-horizontal params">
							  <dt>-s, --seed=n</dt><dd>Set seed for selecting address permutation</dd>
							</dl>
							<br/>
-->


							<a name="blacklisting"></a> 
							<h3>Blacklisting and Whitelisting</h3>
							<p>ZMap supports both blacklisting and whitelisting network prefixes. If ZMap is not provided with blacklist or whitelist parameters, ZMap will scan all IPv4 address (including local, reserved, and multicast addresses). If a blacklist file is specified, network prefixes in the blacklisted segments will not be scanned; if a whitelist file is provided, only network prefixes in the whitelist file will be scanned. A whitelist and blacklist file can be used in coordination. Whitelist and blacklist files can be specified on the command-line as follows:</p>

<dl class="dl-horizontal params">
  <dt>-b, --blacklist-file=path</dt><dd>File of subnets to blacklist in CIDR notation, e.g. 192.168.0.0/16</dd>
	<dt>-w, --whitelist-file=path</dt><dd>File of subnets to limit scan to in CIDR notation, e.g. 192.168.0.0/16</dd>
</dl>
	
<p>Blacklist files should be formatted with a single network prefix in <a href="http://en.wikipedia.org/wiki/CIDR_notation">CIDR notation</a> per line. Comments are allowed using the <code>#</code> character. Example:</p>
						
<div class="indent"><pre>
0.0.0.0/8           # reserved
10.0.0.0/8          # RFC 1918
192.168.0.0/16      # RFC 1918
172.16.0.0/12       # RFC 1918
224.0.0.0/3         # multicast/future use
169.254.0.0/16      # link local addresses</pre></div>
							<p><span class="label label-info">Heads Up!</span> If you are looking to scan only a random portion of the internet, checkout <a href="#ratelimiting">Sampling</a>, instead of using whitelisting and blacklisting.</p>	
							<br/>


							<a name="ratelimiting"></a> 
							<h3>Rate Limiting and Sampling</h3>

                            <p>By default, ZMap will scan at the fastest rate
that your network adaptor supports. In our experiences on commodity hardware,
this is generally around 95-98% of the theoretical speed of gigabit Ethernet,
which may be faster than your upstream provider can handle. ZMap will <b>not</b>
automatically adjust its send-rate based on your upstream provider.  You may
need to manually adjust your send-rate to reduce packet drops and incorrect results.</p>

							<dl class="dl-horizontal params">
								<dt>-r, --rate=pps</dt><dd>Set maximum send rate in packets/sec</dd>
                                <dt>-B, --bandwidth=bps</dt><dd>Set send rate in bits/sec (supports suffixes G, M, and K). This overrides the <code>--rate</code> flag.</dd>
							</dl>

							<p>ZMap also allows random sampling of the IPv4 address space by specifying max-targets and/or max-runtime. Because hosts are scanned in a random permutation generated per scan instantiation, limiting a scan to <emph>n</emph> hosts will perform a random sampling of <emph>n</emph> hosts. Command-line options:</p>
							<dl class="dl-horizontal params">
							  <dt>-n, --max-targets=n</dt><dd>Cap number of targets to probe</dd>
                              <dt>-N, --max-results=n</dt><dd>Cap number of results (exit after receiving this many positive results)</dd>
							  <dt>-t, --max-runtime=s</dt><dd>Cap length of time for sending packets (in seconds)</dd>
                              <dt>-s, --seed=n</dt><dd>Seed used to select address permutation. Specify the same seed in order to scan addresses
                                                    in the same order for different ZMap runs.</dd>
							</dl>
							<p>For example, if you wanted to scan the same one million hosts on the Internet for multiple scans, you could set a predetermined seed and cap the number of scanned hosts similar to the following:</p>
							<div class="indent"><pre><b>zmap -p 443 -s 3 -n 1000000 -o results</b></pre></div>
							<p>In order to determine which one million hosts were going to be scanned, you could run the scan in dry-run mode which will print out the packets that would be sent instead of performing the actual scan.</p>
							<div class="indent"><pre><b>zmap -p 443 -s 3 -n 1000000 --dryrun | grep daddr
	| awk -F'daddr: ' '{print $2}' | sed 's/ |.*//;' </b></pre></div>
							<br/>


							<a name="multiple"></a> 
							<h3>Sending Multiple Packets</h3>
							<p>ZMap supports sending multiple probes to each host. Increasing this number both increases 
                            scan time and hosts reached. However, we find that the increase in scan time (~100% per additional probe)
                            greatly outweighs the increase in hosts reached (~1% per additional probe).</p>
			
							<dl class="dl-horizontal params">
							  <dt>-P, --probes=n</dt><dd>The number of unique probes to send to each IP (default=1)</dd>
							</dl>
							<br/>
				</div>
			</div>
			</div>
			</div>
		</div>
	</body>
</html>
